using Pure.DI;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.DependencyInjection;
// open user domain
using static Domain.User;

namespace Composition;

// required for F# interop, otherwise confused
// methods inside are generated by PureDI generator, - F# compiler gets confused and doesn't provide intellisense
public static class ServiceProviderExtensions
{
    public static IServiceCollection AddCompositionRoot(this IServiceCollection serviceCollection) =>
        CompositionRoot.AddCompositionRoot(serviceCollection);
}

public static partial class CompositionRoot
{
    // Actually, this code never runs and the method might have any name or be a constructor for instance
    // because this is just a hint to set up an object (classes/delegates) graph.
    // instances are aggressively inlined upon serviceProvider.GetService(), resulting in clean function given directly to requestor
    // partial application of it (.To(fun ctx -> ...factory_code...)) handled in compile time
    private static void Setup() => DI.Setup(nameof(CompositionRoot))
        
        .Bind<ConnectionString>()
        .As(Lifetime.Singleton)
        .To(_ => connectionString)

        .Bind<GetPipelineContext>()
        .As(Lifetime.Singleton)
        .To(ctx => 
            getPipelineContext(
                ctx.Resolve<ConnectionString>(),
                ctx.Resolve<ILogger<GetPipelineContext>>()))
        
        .Bind<GetUserById>()
        .As(Lifetime.Transient)
        .Tags("_decorate")
        .To(ctx => 
            getUserById(
                ctx.Resolve<ConnectionString>(),
                ctx.Resolve<GetPipelineContext>(),
                ctx.Resolve<ILogger<GetUserById>>()))
        
        .Bind<GetUserById>()
        .As(Lifetime.Transient)
        .To(ctx => 
            getUserByIdDecorator(
                ctx.Resolve<GetUserById>("_decorate"), 
                ctx.Resolve<ILogger<GetUserById>>()));
}